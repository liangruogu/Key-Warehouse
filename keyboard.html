<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>3D 键盘客制化</title>
    <style>
        :root { --primary: #007bff; --glass: rgba(20, 20, 20, 0.85); }
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background-color: #1a1a1a;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            user-select: none;
            -webkit-tap-highlight-color: transparent;
            touch-action: none;
        }

        #view-controls {
            position: absolute;
            top: env(safe-area-inset-top, 30px);
            left: 30px;
            display: flex;
            gap: 8px;
            z-index: 10;
        }

        .view-btn {
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
            border: 1px solid rgba(255,255,255,0.2);
            padding: 6px 14px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 12px;
            backdrop-filter: blur(4px);
            transition: all 0.2s;
        }
        .view-btn:hover, .view-btn:active { background: rgba(255, 255, 255, 0.2); border-color: #fff; }

        #bottom-ui {
            position: absolute;
            bottom: env(safe-area-inset-bottom, 40px);
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 25px;
            width: 100%;
            pointer-events: none;
        }

        #btn-explode {
            pointer-events: auto;
            background: linear-gradient(135deg, #3a8ee6, #00bfff);
            color: white;
            border: none;
            padding: 10px 32px;
            font-size: 15px;
            font-weight: 600;
            border-radius: 50px;
            cursor: pointer;
            box-shadow: 0 4px 15px rgba(0, 191, 255, 0.3);
            transition: transform 0.2s;
            letter-spacing: 1px;
        }
        #btn-explode:hover { transform: scale(1.05); }

        .selector-container {
            pointer-events: auto;
            display: flex;
            gap: 40px;
            background: var(--glass);
            padding: 20px 40px;
            border-radius: 20px;
            backdrop-filter: blur(15px);
            border: 1px solid rgba(255,255,255,0.1);
            box-shadow: 0 20px 50px rgba(0,0,0,0.5);
        }

        .switcher {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 10px;
            min-width: 180px;
        }

        .switcher-label {
            color: #888;
            font-size: 12px;
            text-transform: uppercase;
            letter-spacing: 1px;
            font-weight: 700;
        }

        .switcher-controls {
            display: flex;
            align-items: center;
            justify-content: space-between;
            width: 100%;
            background: rgba(255,255,255,0.05);
            border-radius: 12px;
            padding: 5px;
        }

        .arrow-btn {
            background: transparent;
            border: none;
            color: #fff;
            font-size: 18px;
            cursor: pointer;
            width: 30px;
            height: 30px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 8px;
            transition: background 0.2s;
            opacity: 0.7;
        }
        .arrow-btn:hover { background: rgba(255,255,255,0.1); opacity: 1; }

        .option-display {
            color: #fff;
            font-size: 14px;
            font-weight: 500;
            text-align: center;
            width: 100px;
        }

        #loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #666;
        }

        /* 移动端样式 */
        @media screen and (max-width: 768px) {
            #view-controls {
                top: env(safe-area-inset-top, 10px);
                left: 50%;
                transform: translateX(-50%);
            }

            #bottom-ui {
                bottom: env(safe-area-inset-bottom, 20px);
                gap: 15px;
                width: calc(100% - 40px);
            }

            #btn-explode {
                padding: 12px 40px;
                font-size: 16px;
            }

            .selector-container {
                gap: 20px;
                padding: 15px 25px;
                width: 100%;
                max-width: 400px;
            }

            .switcher-label {
                font-size: 11px;
            }

            .switcher-controls {
                padding: 6px;
            }

            .arrow-btn {
                font-size: 20px;
                width: 36px;
                height: 36px;
            }

            .option-display {
                font-size: 13px;
            }

            .switcher {
                min-width: auto;
                flex: 1;
            }
        }

        /* 横屏移动端适配 */
        @media screen and (max-width: 768px) and (orientation: landscape) {
            #bottom-ui {
                flex-direction: row;
                gap: 20px;
                width: auto;
            }

            .selector-container {
                padding: 12px 20px;
                gap: 30px;
            }

            .switcher-label {
                display: none;
            }

            #btn-explode {
                padding: 10px 30px;
                font-size: 14px;
            }
        }

        @supports (padding: max(0px)) {
            #view-controls {
                top: max(10px, env(safe-area-inset-top));
            }
            #bottom-ui {
                bottom: max(20px, env(safe-area-inset-bottom));
            }
        }
    </style>
</head>
<body>

    <div id="loading">组装键盘零件中...</div>

    <div id="view-controls">
        <button class="view-btn" onclick="changeView('default')">透视</button>
        <button class="view-btn" onclick="changeView('top')">俯视</button>
        <button class="view-btn" onclick="changeView('side')">侧面</button>
    </div>

    <div id="bottom-ui">
        <button id="btn-explode">查看内部结构</button>

        <div class="selector-container">
            <div class="switcher">
                <span class="switcher-label">Keycap Theme</span>
                <div class="switcher-controls">
                    <button class="arrow-btn" onclick="cycleTheme(-1)">❮</button>
                    <span id="theme-display" class="option-display">温莎蓝</span>
                    <button class="arrow-btn" onclick="cycleTheme(1)">❯</button>
                </div>
            </div>

            <div style="width:1px; background:rgba(255,255,255,0.1);"></div>

            <div class="switcher">
                <span class="switcher-label">Switch Type</span>
                <div class="switcher-controls">
                    <button class="arrow-btn" onclick="cycleSwitch(-1)">❮</button>
                    <span id="switch-display" class="option-display">轻音红轴</span>
                    <button class="arrow-btn" onclick="cycleSwitch(1)">❯</button>
                </div>
            </div>
        </div>
    </div>

    <script type="importmap">
        {
            "imports": {
                "three": "https://esm.sh/three@0.160.0",
                "three/addons/": "https://esm.sh/three@0.160.0/examples/jsm/",
                "gsap": "https://esm.sh/gsap@3.12.4"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { RoundedBoxGeometry } from 'three/addons/geometries/RoundedBoxGeometry.js';
        import gsap from 'gsap';

        const isMobile = window.innerWidth <= 768;
        let isPortrait = window.innerHeight > window.innerWidth;

        const layout = [
            [0, 0, 1, 'Esc', 'mod'],
            [0, 1.25, 1, 'F1', 'f_key'], [0, 2.25, 1, 'F2', 'f_key'], [0, 3.25, 1, 'F3', 'f_key'], [0, 4.25, 1, 'F4', 'f_key'],
            [0, 5.75, 1, 'F5', 'f_key'], [0, 6.75, 1, 'F6', 'f_key'], [0, 7.75, 1, 'F7', 'f_key'], [0, 8.75, 1, 'F8', 'f_key'],
            [0, 10.25, 1, 'F9', 'f_key'], [0, 11.25, 1, 'F10', 'f_key'], [0, 12.25, 1, 'F11', 'f_key'], [0, 13.25, 1, 'F12', 'f_key'],
            [0, 14.75, 1, 'Del', 'mod'],

            [1, 0, 1, '`', 'alpha'], [1, 1, 1, '1', 'alpha'], [1, 2, 1, '2', 'alpha'], [1, 3, 1, '3', 'alpha'], [1, 4, 1, '4', 'alpha'], [1, 5, 1, '5', 'alpha'], [1, 6, 1, '6', 'alpha'], [1, 7, 1, '7', 'alpha'], [1, 8, 1, '8', 'alpha'], [1, 9, 1, '9', 'alpha'], [1, 10, 1, '0', 'alpha'], [1, 11, 1, '-', 'alpha'], [1, 12, 1, '=', 'alpha'],
            [1, 13, 2, 'Back', 'mod'],
            [1, 15, 1, 'Home', 'mod'],

            [2, 0, 1.5, 'Tab', 'mod'], [2, 1.5, 1, 'Q', 'alpha'], [2, 2.5, 1, 'W', 'alpha'], [2, 3.5, 1, 'E', 'alpha'], [2, 4.5, 1, 'R', 'alpha'], [2, 5.5, 1, 'T', 'alpha'], [2, 6.5, 1, 'Y', 'alpha'], [2, 7.5, 1, 'U', 'alpha'], [2, 8.5, 1, 'I', 'alpha'], [2, 9.5, 1, 'O', 'alpha'], [2, 10.5, 1, 'P', 'alpha'], [2, 11.5, 1, '[', 'alpha'], [2, 12.5, 1, ']', 'alpha'],
            [2, 13.5, 1.5, '\\', 'alpha'],
            [2, 15, 1, 'PgUp', 'mod'],

            [3, 0, 1.75, 'Caps', 'mod'], [3, 1.75, 1, 'A', 'alpha'], [3, 2.75, 1, 'S', 'alpha'], [3, 3.75, 1, 'D', 'alpha'], [3, 4.75, 1, 'F', 'alpha'], [3, 5.75, 1, 'G', 'alpha'], [3, 6.75, 1, 'H', 'alpha'], [3, 7.75, 1, 'J', 'alpha'], [3, 8.75, 1, 'K', 'alpha'], [3, 9.75, 1, 'L', 'alpha'], [3, 10.75, 1, ';', 'alpha'], [3, 11.75, 1, "'", 'alpha'],
            [3, 12.75, 2.25, 'Enter', 'accent'],
            [3, 15, 1, 'PgDn', 'mod'],

            [4, 0, 2.25, 'Shift', 'mod'], [4, 2.25, 1, 'Z', 'alpha'], [4, 3.25, 1, 'X', 'alpha'], [4, 4.25, 1, 'C', 'alpha'], [4, 5.25, 1, 'V', 'alpha'], [4, 6.25, 1, 'B', 'alpha'], [4, 7.25, 1, 'N', 'alpha'], [4, 8.25, 1, 'M', 'alpha'], [4, 9.25, 1, ',', 'alpha'], [4, 10.25, 1, '.', 'alpha'], [4, 11.25, 1, '/', 'alpha'],
            [4, 12.25, 1.75, 'Shift', 'mod'],
            [4, 14, 1, '↑', 'accent'],
            [4, 15, 1, 'End', 'mod'],

            [5, 0, 1.25, 'Ctrl', 'mod'], [5, 1.25, 1.25, 'Win', 'mod'], [5, 2.5, 1.25, 'Alt', 'mod'],
            [5, 3.75, 6.25, '', 'space'],
            [5, 10, 1, 'Alt', 'mod'], [5, 11, 1, 'Fn', 'mod'], [5, 12, 1, 'Ctrl', 'mod'],
            [5, 13, 1, '←', 'accent'], [5, 14, 1, '↓', 'accent'], [5, 15, 1, '→', 'accent']
        ];

        const themes = [
            {
                name: "温莎蓝 (Blue)",
                id: 'mchose_blue',
                rules: {
                    'alpha': { bg: 0xffffff, text: '#8DB4D6' },
                    'mod':   { bg: 0x8DB4D6, text: '#ffffff' },
                    'f_key': { bg: 0xffffff, text: '#8DB4D6' },
                    'accent':{ bg: 0x8DB4D6, text: '#ffffff' },
                    'space': { bg: 0x8DB4D6, text: '#ffffff' },
                    'case': 0xf2f2f2
                }
            },
            {
                name: "青墨白 (Green)",
                id: 'retro_green',
                rules: {
                    'alpha': { bg: 0xffffff, text: '#000000' },
                    'mod':   { bg: 0x111111, text: '#ffffff' },
                    'f_key': { bg: 0xffffff, text: '#000000' },
                    'accent':{ bg: 0x8bc34a, text: '#000000' },
                    'space': { bg: 0x8bc34a, text: '#ffffff' },
                    'case': 0xffffff
                }
            },
            {
                name: "瑰丽黑 (Red)",
                id: 'dark_red',
                rules: {
                    'alpha': { bg: 0x222222, text: '#ff4444' },
                    'mod':   { bg: 0x880000, text: '#ffffff' },
                    'f_key': { bg: 0x222222, text: '#ff4444' },
                    'accent':{ bg: 0xcc0000, text: '#000000' },
                    'space': { bg: 0x222222, text: '#ffffff' },
                    'case': 0x111111
                }
            },
            {
                name: "极简白 (White)",
                id: 'pure_white',
                rules: {
                    'alpha': { bg: 0xffffff, text: '#333333' },
                    'mod':   { bg: 0xeeeeee, text: '#555555' },
                    'f_key': { bg: 0xffffff, text: '#333333' },
                    'accent':{ bg: 0x000000, text: '#ffffff' },
                    'space': { bg: 0xffffff, text: '#333333' },
                    'case': 0xe0e0e0
                }
            }
        ];

        const switches = [
            { name: "轻音红轴", color: 0xff4d4d },
            { name: "清脆青轴", color: 0x00bfff },
            { name: "段落茶轴", color: 0x8b4513 },
            { name: "快银轴",   color: 0xc0c0c0 },
            { name: "紫金轴",   color: 0x800080 }
        ];

        let scene, camera, renderer, controls;
        let keyboardGroup, keycapsGroup, switchesGroup, plateGroup, caseGroup;
        let currentThemeIndex = 0;
        let currentSwitchIndex = 0;
        let isExploded = false;

        const commonMat = {
            case: new THREE.MeshStandardMaterial({ color: 0xf2f2f2, roughness: 0.6 }),
            plate: new THREE.MeshStandardMaterial({ color: 0xdddddd, roughness: 0.4, metalness: 0.5 }),
            switchHousing: new THREE.MeshStandardMaterial({ color: 0xffffff, opacity: 0.8, transparent: true }),
            switchStem: new THREE.MeshStandardMaterial({ color: switches[0].color }),
        };

        function checkOrientation() {
            isPortrait = window.innerHeight > window.innerWidth;
            updateCameraPosition();
        }

        function updateCameraPosition() {
            if (isMobile) {
                if (isPortrait) {
                    camera.position.set(0, 18, 12);
                } else {
                    camera.position.set(0, 12, 18);
                }
            } else {
                camera.position.set(0, 25, 15);
            }
            camera.lookAt(0, 0, 0);
        }

        init();
        animate();

        function init() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x1a1a1a);
            scene.fog = new THREE.Fog(0x1a1a1a, 20, 80);

            const aspect = window.innerWidth / window.innerHeight;
            camera = new THREE.PerspectiveCamera(45, aspect, 0.1, 1000);
            updateCameraPosition();

            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            renderer.outputColorSpace = THREE.SRGBColorSpace;
            document.body.appendChild(renderer.domElement);

            const ambient = new THREE.AmbientLight(0xffffff, 0.5);
            scene.add(ambient);

            const mainLight = new THREE.DirectionalLight(0xffffff, 1.5);
            mainLight.position.set(5, 15, 10);
            mainLight.castShadow = true;
            mainLight.shadow.mapSize.set(2048, 2048);
            scene.add(mainLight);

            const fillLight = new THREE.DirectionalLight(0xccddff, 0.5);
            fillLight.position.set(-10, 5, -5);
            scene.add(fillLight);

            controls = new OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;
            controls.maxPolarAngle = Math.PI / 2 - 0.1;
            controls.minDistance = isMobile ? 10 : 5;
            controls.maxDistance = isMobile ? 40 : 50;
            controls.enablePan = false;

            buildKeyboard();

            document.getElementById('loading').style.display = 'none';

            window.addEventListener('resize', onResize);
            window.addEventListener('orientationchange', checkOrientation);
            document.getElementById('btn-explode').addEventListener('click', toggleExplode);

            window.cycleTheme = cycleTheme;
            window.cycleSwitch = cycleSwitch;
            window.changeView = changeView;
        }

        function buildKeyboard() {
            keyboardGroup = new THREE.Group();
            scene.add(keyboardGroup);

            caseGroup = new THREE.Group();
            plateGroup = new THREE.Group();
            switchesGroup = new THREE.Group();
            keycapsGroup = new THREE.Group();

            keyboardGroup.add(caseGroup, plateGroup, switchesGroup, keycapsGroup);

            const u = 1.9;
            const maxX = 16.5 * u;
            const maxZ = 6.5 * u;
            const marginX = 0.3 * u;
            const offsetX = -maxX / 2 + marginX;
            const offsetZ = -maxZ / 2;

            layout.forEach(key => {
                const [row, colX, widthU, label, type] = key;

                const x = colX * u + offsetX + (widthU * u) / 2;
                const z = row * u + offsetZ + u / 2;

                const isStaggered = colX >= 15;
                const gapSize = isStaggered ? 0.15 : 0.08;
                const widthReal = widthU * u - gapSize;
                const depthReal = u - 0.08;

                const sw = new THREE.Group();
                sw.position.set(x, 0.15, z);

                const housing = new THREE.Mesh(new THREE.BoxGeometry(1.4, 0.5, 1.4), commonMat.switchHousing);
                housing.position.y = 0.15;
                sw.add(housing);

                const spring = new THREE.Mesh(new THREE.CylinderGeometry(0.08, 0.08, 0.3, 8), new THREE.MeshStandardMaterial({ color: 0xdddddd, metalness: 0.8 }));
                spring.position.y = 0.15;
                sw.add(spring);

                const stemBase = new THREE.Mesh(new THREE.CylinderGeometry(0.12, 0.12, 0.15, 8), commonMat.switchStem);
                stemBase.position.y = 0.2;
                sw.add(stemBase);

                const stemPost = new THREE.Mesh(new THREE.CylinderGeometry(0.1, 0.1, 0.2, 8), commonMat.switchStem);
                stemPost.position.y = 0.38;
                sw.add(stemPost);

                const cross1 = new THREE.Mesh(new THREE.BoxGeometry(0.6, 0.08, 0.14), commonMat.switchStem);
                cross1.position.y = 0.48;
                sw.add(cross1);
                const cross2 = new THREE.Mesh(new THREE.BoxGeometry(0.14, 0.08, 0.6), commonMat.switchStem);
                cross2.position.y = 0.48;
                sw.add(cross2);

                const stemTop = new THREE.Mesh(new THREE.CylinderGeometry(0.12, 0.1, 0.06, 8), commonMat.switchStem);
                stemTop.position.y = 0.54;
                sw.add(stemTop);

                const contact = new THREE.Mesh(new THREE.CylinderGeometry(0.06, 0.04, 0.08, 8), new THREE.MeshStandardMaterial({ color: 0xcccccc, metalness: 0.9 }));
                contact.position.y = 0.04;
                sw.add(contact);
                switchesGroup.add(sw);

                const keyGeo = new RoundedBoxGeometry(widthReal, 1.2, depthReal, 4, 0.1);

                const pos = keyGeo.attributes.position;
                for(let i=0; i<pos.count; i++){
                    if(pos.getY(i) > 0){
                        const shrinkRatio = widthU >= 6.25 ? 0.92 : 0.85;
                        pos.setX(i, pos.getX(i) * shrinkRatio);
                        pos.setZ(i, pos.getZ(i) * 0.85);
                        pos.setY(i, pos.getY(i) - pos.getZ(i) * 0.15);
                    }
                }
                keyGeo.computeVertexNormals();

                computeTopFaceUV(keyGeo, widthReal, depthReal);

                const sideMat = new THREE.MeshStandardMaterial({
                    color: 0xffffff, roughness: 0.7, metalness: 0.05, transparent: false
                });
                const topMat = new THREE.MeshStandardMaterial({
                    color: 0xffffff, roughness: 0.7, metalness: 0.05, transparent: false
                });
                const keyMats = [sideMat, sideMat, topMat, sideMat, sideMat, sideMat];

                const keyMesh = new THREE.Mesh(keyGeo, keyMats);
                keyMesh.position.set(x, 0.4, z);
                keyMesh.castShadow = true;
                keyMesh.receiveShadow = true;

                keyMesh.userData = {
                    type: type,
                    label: label,
                    isKeycap: true,
                    sideMat: sideMat,
                    topMat: topMat,
                    widthU: widthU,
                    widthReal: widthReal,
                    depthReal: depthReal
                };

                keycapsGroup.add(keyMesh);
            });

            const caseW = 17.0 * u;
            const caseD = 6.8 * u;

            const caseMesh = new THREE.Mesh(
                new RoundedBoxGeometry(caseW, 2.2, caseD, 8, 0.5),
                commonMat.case
            );
            caseMesh.position.y = -1.1;
            caseMesh.receiveShadow = true;
            caseGroup.add(caseMesh);

            const plateMesh = new THREE.Mesh(
                new THREE.BoxGeometry(caseW - 0.8, 0.08, caseD - 0.8),
                commonMat.plate
            );
            plateMesh.position.y = -0.5;
            plateGroup.add(plateMesh);

            applyTheme(0);
        }

        function computeTopFaceUV(geometry, width, depth) {
            const uv = geometry.attributes.uv;
            const pos = geometry.attributes.position;

            for(let i = 0; i < pos.count; i++) {
                const x = pos.getX(i);
                const z = pos.getZ(i);
                uv.setXY(i, (x / width + 0.5) * 0.9 + 0.05, 0.95 - (z / depth + 0.5) * 0.9);
            }
        }

        function applyTheme(index) {
            const theme = themes[index];
            document.getElementById('theme-display').innerText = theme.name;
            commonMat.case.color.setHex(theme.rules.case);

            keycapsGroup.children.forEach(mesh => {
                if(!mesh.userData.isKeycap) return;

                const rule = theme.rules[mesh.userData.type] || theme.rules['alpha'];

                mesh.userData.sideMat.color.setHex(rule.bg);

                if(mesh.userData.topMat.map) mesh.userData.topMat.map.dispose();

                const texture = createKeyTexture(mesh.userData.label, rule.bg, rule.text, mesh.userData.widthReal, mesh.userData.depthReal);
                mesh.userData.topMat.map = texture;
                mesh.userData.topMat.color.setHex(rule.bg);
                mesh.userData.topMat.needsUpdate = true;
            });
        }

        function createKeyTexture(text, bgColorHex, textColor, widthReal, depthReal) {
            const baseSize = 256;
            const aspectRatio = widthReal / depthReal;

            let canvasWidth, canvasHeight;

            if (aspectRatio > 1.5) {
                canvasWidth = baseSize * aspectRatio;
                canvasHeight = baseSize;
            } else if (aspectRatio < 0.7) {
                canvasWidth = baseSize;
                canvasHeight = baseSize / aspectRatio;
            } else {
                canvasWidth = baseSize;
                canvasHeight = baseSize;
            }

            canvasWidth = Math.min(canvasWidth, 1024);
            canvasHeight = Math.min(canvasHeight, 512);

            const canvas = document.createElement('canvas');
            canvas.width = canvasWidth;
            canvas.height = canvasHeight;
            const ctx = canvas.getContext('2d');

            const col = new THREE.Color(bgColorHex);
            ctx.fillStyle = `rgb(${col.r*255}, ${col.g*255}, ${col.b*255})`;
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            if (text && text.length > 0) {
                ctx.fillStyle = textColor;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';

                let fontSize = Math.min(canvasWidth, canvasHeight) * 0.18;
                fontSize = Math.min(fontSize, 60);
                fontSize = Math.max(fontSize, 12);

                const isLongSpecialKey = ['Shift', 'Enter', 'Space'].includes(text);

                if (text.length === 1) {
                    fontSize = Math.min(canvasWidth, canvasHeight) * 0.22;
                } else if (text.length <= 2) {
                    fontSize = Math.min(canvasWidth, canvasHeight) * 0.2;
                } else if (text.length <= 4) {
                    fontSize = isLongSpecialKey
                        ? Math.min(canvasWidth, canvasHeight) * 0.25
                        : Math.min(canvasWidth, canvasHeight) * 0.14;
                } else {
                    fontSize = isLongSpecialKey
                        ? Math.min(canvasWidth, canvasHeight) * 0.18
                        : Math.min(canvasWidth, canvasHeight) * 0.1;
                }

                ctx.font = `bold ${fontSize}px Arial, sans-serif`;

                ctx.strokeStyle = textColor;
                ctx.lineWidth = fontSize * 0.02;
                ctx.strokeText(text, canvas.width/2, canvas.height/2);

                ctx.fillText(text, canvas.width/2, canvas.height/2);
            }

            const texture = new THREE.CanvasTexture(canvas);
            texture.anisotropy = 16;
            texture.wrapS = THREE.ClampToEdgeWrapping;
            texture.wrapT = THREE.ClampToEdgeWrapping;
            return texture;
        }

        function cycleTheme(dir) {
            currentThemeIndex = (currentThemeIndex + dir + themes.length) % themes.length;
            applyTheme(currentThemeIndex);
        }

        function cycleSwitch(dir) {
            currentSwitchIndex = (currentSwitchIndex + dir + switches.length) % switches.length;
            const sw = switches[currentSwitchIndex];
            document.getElementById('switch-display').innerText = sw.name;

            gsap.to(commonMat.switchStem.color, {
                r: new THREE.Color(sw.color).r,
                g: new THREE.Color(sw.color).g,
                b: new THREE.Color(sw.color).b,
                duration: 0.3
            });
        }

        function toggleExplode() {
            isExploded = !isExploded;
            const btn = document.getElementById('btn-explode');
            btn.innerText = isExploded ? "还原视图" : "查看内部结构";
            btn.style.background = isExploded ? "#666" : "linear-gradient(135deg, #3a8ee6, #00bfff)";

            const targetY = isExploded ? 1 : 0;
            const anim = { val: isExploded ? 0 : 1 };

            gsap.to(anim, {
                val: targetY,
                duration: 1.0,
                ease: "power2.inOut",
                onUpdate: () => {
                    const v = anim.val;
                    plateGroup.position.y = -0.5 + v * 2.5;
                    switchesGroup.position.y = 0.15 + v * 3;
                    keycapsGroup.position.y = 0.4 + v * 5;

                    keyboardGroup.rotation.y = isExploded ? Math.sin(Date.now()*0.001)*0.1 : 0;
                }
            });
        }

        function changeView(type) {
            const pos = {
                default: isMobile ? (isPortrait ? {x:0, y:18, z:12} : {x:0, y:12, z:18}) : {x:0, y:25, z:15},
                top: {x:0, y:30, z:1},
                side: isMobile ? (isPortrait ? {x:-20, y:8, z:0} : {x:-25, y:10, z:0}) : {x:-25, y:10, z:0}
            }[type];

            gsap.to(camera.position, {
                x: pos.x, y: pos.y, z: pos.z,
                duration: 0.8, ease: "power2.out"
            });
        }

        function onResize() {
            checkOrientation();
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function animate() {
            requestAnimationFrame(animate);
            if(isExploded) {
                keyboardGroup.rotation.y = Math.sin(Date.now() * 0.0005) * 0.15;
            } else {
                keyboardGroup.rotation.y = 0;
            }
            controls.update();
            renderer.render(scene, camera);
        }
    </script>
</body>
</html>
